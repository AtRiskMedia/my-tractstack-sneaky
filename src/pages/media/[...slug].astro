---
import { promises as fs } from 'node:fs';
import path from 'node:path';

// DO NOT USE IN PRODUCTION !!!
// this is a stop-gap for dev testing ...

// configure nginx to serve files on /media !!
// see the docs

export const prerender = false;

const MIME_TYPES: Record<string, string> = {
  '.css': 'text/css',
  '.js': 'application/javascript',
  '.json': 'application/json',
  '.svg': 'image/svg+xml',
  '.png': 'image/png',
  '.jpg': 'image/jpeg',
  '.jpeg': 'image/jpeg',
  '.gif': 'image/gif',
  '.webp': 'image/webp',
  '.woff': 'font/woff',
  '.woff2': 'font/woff2',
  '.ttf': 'font/ttf',
  '.otf': 'font/otf',
  '.ico': 'image/x-icon',
};

const { slug } = Astro.params;

const tenant =
  Astro.locals.tenant?.id || import.meta.env.PUBLIC_TENANTID || 'default';

const baseServerPath = import.meta.env.PRIVATE_GO_BACKEND_PATH;
if (!baseServerPath) {
  console.error(
    '[ERROR] PRIVATE_GO_BACKEND_PATH environment variable is not set.'
  );
  return new Response('Server configuration error', { status: 500 });
}

if (!slug) throw new Error(`Invalid path for tenant "${tenant}".`);

try {
  // Construct the file path using the correct tenant ID
  const fullPath = path.join(baseServerPath, 'config', tenant, 'media', slug);

  // Security check to prevent path traversal
  const tenantMediaRoot = path.join(baseServerPath, 'config', tenant, 'media');
  if (!path.resolve(fullPath).startsWith(path.resolve(tenantMediaRoot))) {
    throw new Error(`Invalid path for tenant "${tenant}".`);
  }

  const fileBuffer = await fs.readFile(fullPath);
  const extension = path.extname(slug).toLowerCase();
  const mimeType = MIME_TYPES[extension] || 'application/octet-stream';

  return new Response(fileBuffer, {
    status: 200,
    headers: { 'Content-Type': mimeType },
  });
} catch (error) {
  console.error(`Could not serve media file: ${slug} for tenant ${tenant}.`);
  return new Response(null, { status: 404, statusText: 'Not Found' });
}
---
